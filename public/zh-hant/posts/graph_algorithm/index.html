<!DOCTYPE html>
<html lang="zh-hant">

<head>
  <title>
  解題：Graph 資料結構與演算法 · Wayne Chang 的小筆記
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Wayne Chang">
<meta name="description" content="在 LeetCode、競程或面試中，許多圖論題目會涉及「最短路徑」或「圖的遍歷」等情境。根據圖的性質（是否有權重、有沒有負權、有沒有負環等），我們可以快速判斷使用哪種演算法來達到最好的效果。

以下先整理了常見的圖論題型與其對應的最佳演算法，後續我們再來一一介紹每個演算法~

  解題場景
  
    
    Link to heading
  


  
      
          場景
          最適演算法
          適用情況描述
      
  
  
      
          無權圖（所有邊為 1）
          BFS
          最短步數問題（地圖、字串轉換等）
      
      
          有非負權重
          Dijkstra
          各路徑代價不同但都非負
      
      
          有負權重但無負環
          Bellman-Ford
          有負邊但沒有負環，適合部分金融問題等
      
      
          有負環需偵測
          Bellman-Ford / Floyd-Warshall
          判斷圖是否有邏輯錯誤或陷阱
      
      
          所有點對最短路徑
          Floyd-Warshall
          多源最短路徑查詢，適合節點數不大的圖
      
      
          權重只有 0 或 1
          0-1 BFS
          更快的最短路計算，適合特殊地圖類型
      
  



  BFS 演算法
  
    
    Link to heading
  

廣度優先搜尋演算法（英語：Breadth-first search，縮寫：BFS），一種圖形搜尋演算法。簡單的說，BFS是從根節點開始，沿著樹的寬度遍歷樹的節點。如果所有節點均被訪問，則演算法中止(對這是抄維基的)
BFS 可用在找無權圖(所有邊線的權重都是1)的最短路線，像是迷宮找路、最短跳躍步數等等，通常透過使用 list 或 dictionary 建立各節點相連的鄰接表，再用 queue 來一步步找到最短距離
例題:
給你一個無權圖，有 n 個節點（從 0 到 n-1），和一組邊 edges，每條邊連接兩個節點。請你計算從起點 start 出發，到每個節點的最短距離（用幾步表示）。
若某節點無法到達，回傳距離為 -1。">
<meta name="keywords" content="software,blog,developer,aspnet,python">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="解題：Graph 資料結構與演算法">
  <meta name="twitter:description" content="在 LeetCode、競程或面試中，許多圖論題目會涉及「最短路徑」或「圖的遍歷」等情境。根據圖的性質（是否有權重、有沒有負權、有沒有負環等），我們可以快速判斷使用哪種演算法來達到最好的效果。
以下先整理了常見的圖論題型與其對應的最佳演算法，後續我們再來一一介紹每個演算法~
解題場景Link to heading場景 最適演算法 適用情況描述 無權圖（所有邊為 1） BFS 最短步數問題（地圖、字串轉換等） 有非負權重 Dijkstra 各路徑代價不同但都非負 有負權重但無負環 Bellman-Ford 有負邊但沒有負環，適合部分金融問題等 有負環需偵測 Bellman-Ford / Floyd-Warshall 判斷圖是否有邏輯錯誤或陷阱 所有點對最短路徑 Floyd-Warshall 多源最短路徑查詢，適合節點數不大的圖 權重只有 0 或 1 0-1 BFS 更快的最短路計算，適合特殊地圖類型 BFS 演算法Link to heading廣度優先搜尋演算法（英語：Breadth-first search，縮寫：BFS），一種圖形搜尋演算法。簡單的說，BFS是從根節點開始，沿著樹的寬度遍歷樹的節點。如果所有節點均被訪問，則演算法中止(對這是抄維基的)
BFS 可用在找無權圖(所有邊線的權重都是1)的最短路線，像是迷宮找路、最短跳躍步數等等，通常透過使用 list 或 dictionary 建立各節點相連的鄰接表，再用 queue 來一步步找到最短距離
例題:
給你一個無權圖，有 n 個節點（從 0 到 n-1），和一組邊 edges，每條邊連接兩個節點。請你計算從起點 start 出發，到每個節點的最短距離（用幾步表示）。
若某節點無法到達，回傳距離為 -1。">

<meta property="og:url" content="http://www.example.com/zh-hant/posts/graph_algorithm/">
  <meta property="og:site_name" content="Wayne Chang 的小筆記">
  <meta property="og:title" content="解題：Graph 資料結構與演算法">
  <meta property="og:description" content="在 LeetCode、競程或面試中，許多圖論題目會涉及「最短路徑」或「圖的遍歷」等情境。根據圖的性質（是否有權重、有沒有負權、有沒有負環等），我們可以快速判斷使用哪種演算法來達到最好的效果。
以下先整理了常見的圖論題型與其對應的最佳演算法，後續我們再來一一介紹每個演算法~
解題場景Link to heading場景 最適演算法 適用情況描述 無權圖（所有邊為 1） BFS 最短步數問題（地圖、字串轉換等） 有非負權重 Dijkstra 各路徑代價不同但都非負 有負權重但無負環 Bellman-Ford 有負邊但沒有負環，適合部分金融問題等 有負環需偵測 Bellman-Ford / Floyd-Warshall 判斷圖是否有邏輯錯誤或陷阱 所有點對最短路徑 Floyd-Warshall 多源最短路徑查詢，適合節點數不大的圖 權重只有 0 或 1 0-1 BFS 更快的最短路計算，適合特殊地圖類型 BFS 演算法Link to heading廣度優先搜尋演算法（英語：Breadth-first search，縮寫：BFS），一種圖形搜尋演算法。簡單的說，BFS是從根節點開始，沿著樹的寬度遍歷樹的節點。如果所有節點均被訪問，則演算法中止(對這是抄維基的)
BFS 可用在找無權圖(所有邊線的權重都是1)的最短路線，像是迷宮找路、最短跳躍步數等等，通常透過使用 list 或 dictionary 建立各節點相連的鄰接表，再用 queue 來一步步找到最短距離
例題:
給你一個無權圖，有 n 個節點（從 0 到 n-1），和一組邊 edges，每條邊連接兩個節點。請你計算從起點 start 出發，到每個節點的最短距離（用幾步表示）。
若某節點無法到達，回傳距離為 -1。">
  <meta property="og:locale" content="zh_hant">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-26T16:30:00+08:00">
    <meta property="article:modified_time" content="2025-06-26T16:30:00+08:00">




<link rel="canonical" href="http://www.example.com/zh-hant/posts/graph_algorithm/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css" integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://www.example.com/zh-hant/">
      Wayne Chang 的小筆記
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/zh-hant/about/">關於我</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/zh-hant/posts/">文章</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/zh-hant/projects/">專案</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/zh-hant/contact/">聯絡資訊</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="/posts/graph_algorithm/">EN</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.example.com/zh-hant/posts/graph_algorithm/">
              解題：Graph 資料結構與演算法
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2025-06-26T16:30:00&#43;08:00">
                6月 26, 2025
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              6-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div class="post-content">
        
        <p>在 LeetCode、競程或面試中，許多圖論題目會涉及「最短路徑」或「圖的遍歷」等情境。根據圖的性質（是否有權重、有沒有負權、有沒有負環等），我們可以快速判斷使用哪種演算法來達到最好的效果。</p>
<br/>
<p>以下先整理了常見的圖論題型與其對應的最佳演算法，後續我們再來一一介紹每個演算法~</p>
<h3 id="解題場景">
  解題場景
  <a class="heading-link" href="#%e8%a7%a3%e9%a1%8c%e5%a0%b4%e6%99%af">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<table>
  <thead>
      <tr>
          <th>場景</th>
          <th>最適演算法</th>
          <th>適用情況描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>無權圖（所有邊為 1）</td>
          <td>BFS</td>
          <td>最短步數問題（地圖、字串轉換等）</td>
      </tr>
      <tr>
          <td>有非負權重</td>
          <td>Dijkstra</td>
          <td>各路徑代價不同但都非負</td>
      </tr>
      <tr>
          <td>有負權重但無負環</td>
          <td>Bellman-Ford</td>
          <td>有負邊但沒有負環，適合部分金融問題等</td>
      </tr>
      <tr>
          <td>有負環需偵測</td>
          <td>Bellman-Ford / Floyd-Warshall</td>
          <td>判斷圖是否有邏輯錯誤或陷阱</td>
      </tr>
      <tr>
          <td>所有點對最短路徑</td>
          <td>Floyd-Warshall</td>
          <td>多源最短路徑查詢，適合節點數不大的圖</td>
      </tr>
      <tr>
          <td>權重只有 0 或 1</td>
          <td>0-1 BFS</td>
          <td>更快的最短路計算，適合特殊地圖類型</td>
      </tr>
  </tbody>
</table>
<br/>
<h3 id="bfs-演算法">
  BFS 演算法
  <a class="heading-link" href="#bfs-%e6%bc%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>廣度優先搜尋演算法（英語：Breadth-first search，縮寫：BFS），一種圖形搜尋演算法。簡單的說，BFS是從根節點開始，沿著樹的寬度遍歷樹的節點。如果所有節點均被訪問，則演算法中止(對這是抄維基的)<br>
BFS 可用在找無權圖(所有邊線的權重都是1)的最短路線，像是迷宮找路、最短跳躍步數等等，通常透過使用 list 或 dictionary 建立各節點相連的鄰接表，再用 queue 來一步步找到最短距離</p>
<p>例題:<br>
給你一個無權圖，有 n 個節點（從 0 到 n-1），和一組邊 edges，每條邊連接兩個節點。請你計算從起點 start 出發，到每個節點的最短距離（用幾步表示）。<br>
若某節點無法到達，回傳距離為 -1。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bfs_shortest_path</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 建立鄰接表</span>
</span></span><span class="line"><span class="cl">    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># 如果是無向圖，記得雙向加邊</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 初始距離設為 -1（表示尚未拜訪）</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># BFS 初始化</span>
</span></span><span class="line"><span class="cl">    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># 還沒拜訪過</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dist</span>
</span></span></code></pre></div><p>測試資料與測試結果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">bfs_shortest_path</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最短距離:&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span></span></code></pre></div><p>Time complexity: <strong>O(V + E)</strong><br>
Space complexity: <strong>O(V)</strong></p>
<p>其中:<br>
V 是城市（節點）數量<br>
E 是航班（邊）數量</p>
<hr>
<br/>
<h3 id="0-1-bfs-演算法">
  0-1 BFS 演算法
  <a class="heading-link" href="#0-1-bfs-%e6%bc%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>算是 BFS 的變形，因為邊線的權重只有 0 和 1 ，當遇到權重為 0 的路線時，則需優先走這個路線，因此將原本使用 queue 改為使用 deque，並透過 appendleft 和 popleft 來優先尋找權重為 0 的路線</p>
<p>例題:<br>
給你一個圖，每個邊的權重要嘛是 0 (免費移動)，要嘛是 1 (需要花費一次移動)，<br>
請從起點 0 找到所有點的最短距離。<br>
列表 &ldquo;edges&rdquo; 內的資料代表 (from, to, weight)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">zero_one_bfs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 建圖：鄰接表</span>
</span></span><span class="line"><span class="cl">    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>  <span class="c1"># 如果是無向圖，記得雙向加邊</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 距離初始化</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dq</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">dq</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">u</span> <span class="o">=</span> <span class="n">dq</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 如果找到更短的距離</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dq</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 0權重 → 優先處理</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>      <span class="c1"># 1權重 → 放後面慢慢處理</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dist</span>
</span></span></code></pre></div><p>測試資料與測試結果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">zero_one_bfs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># ➜ [0, 0, 0, 0]</span>
</span></span></code></pre></div><p>Time complexity: <strong>O(V + E)</strong><br>
Space complexity: <strong>O(V)</strong></p>
<p>其中:<br>
V 是城市（節點）數量<br>
E 是航班（邊）數量</p>
<hr>
<br/>
<h3 id="dijkstra-演算法">
  Dijkstra 演算法
  <a class="heading-link" href="#dijkstra-%e6%bc%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Dijkstra 是荷蘭的 CS 學者，發音讀作 d /ai/ kstra，適合找出有非負權重的最短路徑算法，例如：找最便宜機票路線<br>
算是 Greedy 演算法在 Graph 圖形資料上的應用，使用 BFS 搭配 binary heap 來進行計算，可搭配 set 來記錄走過的節點，或在 heap 中增加一個 list 來記錄完整路徑</p>
<p>例題:<br>
找出從 城市A 飛到 城市F 的最便宜機票路徑，<br>
列表 &ldquo;flights&rdquo; 內的資料代表 [起始城市, 到達城市, 花費]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">heapq</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">find_cheapest_path</span><span class="p">(</span><span class="n">flights</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 建立圖（鄰接表）</span>
</span></span><span class="line"><span class="cl">    <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">src</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dst</span><span class="p">,</span> <span class="n">cost</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 優先隊列：每個元素是 (目前總花費, 當前城市, 路徑)</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">cost</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># 若到達終點，回傳答案</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">city</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">cost</span><span class="p">,</span> <span class="n">path</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># 將鄰近城市加入優先隊列</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">flight_cost</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">city</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">flight_cost</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">[]</span>  <span class="c1"># 無法到達的情況</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 測試資料</span>
</span></span><span class="line"><span class="cl"><span class="n">flights</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 測試：從 A 到 F</span>
</span></span><span class="line"><span class="cl"><span class="n">total_cost</span><span class="p">,</span> <span class="n">route</span> <span class="o">=</span> <span class="n">find_cheapest_path</span><span class="p">(</span><span class="n">flights</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最便宜的票價總和:&#34;</span><span class="p">,</span> <span class="n">total_cost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最便宜的路線:&#34;</span><span class="p">,</span> <span class="s2">&#34; -&gt; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>
</span></span></code></pre></div><p>Time complexity: <strong>O((V + E) log V)</strong><br>
Space complexity: <strong>O(E * V)</strong>, 若不記錄路徑則可降為 <strong>O(E + V)</strong></p>
<p>其中:<br>
V 是城市（節點）數量<br>
E 是航班（邊）數量</p>
<hr>
<br/>
<h3 id="bellman-ford-演算法">
  Bellman-Ford 演算法
  <a class="heading-link" href="#bellman-ford-%e6%bc%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>和 Dijkstra 演算法類似，皆是找出<strong>最短路徑</strong>算法，不同的是 Bellman-Ford 可接受含有<strong>負值</strong>的權重，但遇到<strong>負循環</strong>時則無法計算，可增加是否含有負循環的判斷<br>
若以 &ldquo;找出便宜機票路徑&rdquo; 的範例來說， Bellman-Ford 算法類似於搭配紅眼班機轉機給的折價優惠</p>
<p>例題:<br>
找出從 城市A 飛到 城市C 的最便宜機票路徑，票價可為負值，<br>
列表 &ldquo;flights&rdquo; 內的資料代表 [起始城市, 到達城市, 花費]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">flights</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 初始化圖中所有節點</span>
</span></span><span class="line"><span class="cl">    <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 初始化距離與前驅節點</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">prev</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 執行 V-1 輪鬆弛 (relaxation)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 每輪鬆弛會嘗試讓所有邊的目標節點 v 得到更短的距離</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span>
</span></span><span class="line"><span class="cl">                <span class="n">prev</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 檢查是否存在負環</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 若在第 V 輪還能鬆弛，表示一定有 負環</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;圖中包含負權重環，無法正確計算最短路徑&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 回溯路徑</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">[]</span>  <span class="c1"># 無法到達</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">curr</span> <span class="o">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">path</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 測試：從 A 到 C</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">flights</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># 創造一個負環：B → C → D → B</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cost</span><span class="p">,</span> <span class="n">route</span> <span class="o">=</span> <span class="n">bellman_ford</span><span class="p">(</span><span class="n">flights</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最便宜的票價總和:&#34;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最便宜的路線:&#34;</span><span class="p">,</span> <span class="s2">&#34; -&gt; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;錯誤:&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</span></span></code></pre></div><br/>
<p>此次的執行結果為:</p>
<pre tabindex="0"><code>錯誤: 圖中包含負權重環，無法正確計算最短路徑
</code></pre><p>若拿掉<code>['D', 'B', -2]</code>，則會得到：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">最便宜的票價總和</span><span class="p">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">最便宜的路線</span><span class="p">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span>
</span></span></code></pre></div><br/>
<p>Time complexity: <strong>O(V * E)</strong><br>
Space complexity: <strong>O(V + E)</strong></p>
<p>其中:<br>
V 是城市（節點）數量<br>
E 是航班（邊）數量</p>
<hr>
<br/>
<h3 id="floydwarshall-演算法">
  Floyd–Warshall 演算法
  <a class="heading-link" href="#floydwarshall-%e6%bc%94%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>若 Dijkstra 演算法是找出A到B的最短路徑，那 Floyd–Warshall 演算法就是找出<strong>任兩點之間的最短路徑</strong>，和 Bellman-Ford 一樣可接受含有<strong>負值</strong>的權重，但遇到<strong>負循環</strong>時則無法計算，可增加是否含有負循環的判斷<br>
因為需要三層迴圈來遍歷所以的起點、中繼點和終點，因此時間複雜度較高，適合節點不多但需做多種查詢的情境<br>
若以 &ldquo;找出便宜機票路徑&rdquo; 的範例來說， Floyd–Warshall 算法則類似於找出任兩個城市間的最便宜機票</p>
<p>例題:<br>
找出任兩個城市間的最便宜機票，票價可為負值，<br>
列表 &ldquo;flights&rdquo; 內的資料代表 [起始城市, 到達城市, 花費]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span><span class="n">flights</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 初始化節點清單</span>
</span></span><span class="line"><span class="cl">    <span class="n">cities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">cities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">cities</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>  <span class="c1"># 可讓結果更穩定好讀</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 城市 → 索引 對照表</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">city</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">city</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cities</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="n">inv_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">city</span> <span class="k">for</span> <span class="n">city</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 建立距離與前驅矩陣</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_hop</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 自己到自己距離為 0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">flights</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
</span></span><span class="line"><span class="cl">        <span class="n">next_hop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 核心：三層迴圈進行距離鬆弛</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>          <span class="c1"># 中繼點</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>      <span class="c1"># 起點</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>  <span class="c1"># 終點</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="n">next_hop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_hop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 回傳一個查詢函數，可輸入起訖城市得到最短路徑與成本</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="n">from_city</span><span class="p">,</span> <span class="n">to_city</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">from_city</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idx</span> <span class="ow">or</span> <span class="n">to_city</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">from_city</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">to_city</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># 重建路徑</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_city</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">=</span> <span class="n">next_hop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inv_idx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">from_city</span><span class="p">]][</span><span class="n">idx</span><span class="p">[</span><span class="n">to_city</span><span class="p">]],</span> <span class="n">path</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">get_path</span><span class="p">,</span> <span class="n">dist</span>
</span></span></code></pre></div><p>測試範例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">flights</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">get_path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">floyd_warshall</span><span class="p">(</span><span class="n">flights</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cost</span><span class="p">,</span> <span class="n">route</span> <span class="o">=</span> <span class="n">get_path</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A → D 最便宜票價:&#34;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;路徑:&#34;</span><span class="p">,</span> <span class="s2">&#34; -&gt; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cost</span><span class="p">,</span> <span class="n">route</span> <span class="o">=</span> <span class="n">get_path</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;C → A 最便宜票價:&#34;</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;路徑:&#34;</span><span class="p">,</span> <span class="s2">&#34; -&gt; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>
</span></span></code></pre></div><p>可獲得結果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">A</span> <span class="err">→</span> <span class="n">D</span> <span class="n">最便宜票價</span><span class="p">:</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="n">路徑</span><span class="p">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span> <span class="o">-&gt;</span> <span class="n">D</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span> <span class="err">→</span> <span class="n">A</span> <span class="n">最便宜票價</span><span class="p">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">路徑</span><span class="p">:</span> <span class="n">C</span> <span class="o">-&gt;</span> <span class="n">D</span> <span class="o">-&gt;</span> <span class="n">A</span>
</span></span></code></pre></div><p>若需檢查是否存在負環，可增加這個判斷式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;圖中包含負權重環&#34;</span><span class="p">)</span>
</span></span></code></pre></div><br/>
<p>Time complexity: <strong>O(V³)</strong><br>
Space complexity: <strong>O(V²)</strong></p>
<p>其中:<br>
V 是城市（節點）數量</p>
<br/>
<br/>
<h3 id="參考來源">
  參考來源:
  <a class="heading-link" href="#%e5%8f%83%e8%80%83%e4%be%86%e6%ba%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>Wiki</li>
<li>ChatGPT</li>
</ol>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
     Wayne Chang 
    ·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
